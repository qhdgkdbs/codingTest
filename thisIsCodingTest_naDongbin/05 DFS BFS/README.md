# 그래프 탐색 알고리즘 : DFS / BFS
* 탐색이란 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
* 경로의 특징을 저장해둬야 하는 문제 예를 들면 각 정점에 숫자가 적혀있고 a부터 b까지 가는 경로를 구하는데 경로에 같은 숫자가 있으면 안 된다는 문제 등, 각각의 경로마다 특징을 저장해둬야 할 때는 **DFS**를 사용한다. (BFS는 경로의 특징을 가지지 못함)
* 최단거리 구해야 하는 문제 미로 찾기 등 최단거리를 구해야 할 경우, **BFS**가 유리하다. 왜냐하면 깊이 우선 탐색으로 경로를 검색할 경우 처음으로 발견되는 해답이 최단거리가 아닐 수 있지만,너비 우선 탐색으로 현재 노드에서 가까운 곳부터 찾기 때문에경로를 탐색 시 먼저 찾아지는 해답이 곧 최단거리기 때문.


### 스택 자료구조
* 먼저 들어온 데이터가 나중에 나가는 구조
<pre><code>stack = []
stack.append(5)
stack.append(10)
stack.pop()       #10
</code></pre>
* 최상단 원소부터 출력
```stack[::-1]    # 10 5```
* 최하단 원소부터 출력
```stack          # 5 10 ```


### 큐 자료구조
* 선입선출, 대기열 같은 녀석
* 리스트로도 구현은 가능하지만, 속도 측면에서 deque가 훨씬 유리
<pre><code>from collections import deque

queue = deque()

queue.append(5)
queue.append(10)
queue.popleft()       #5
</code></pre>
* 먼저 들어온 순서대로 출력
```queue    # 5 10```
* 나중에 들어온 원소부터 출력
```queue.reverse()     # 10 5 ```


### 재귀 함수
* 반드시 **종료 조건**을 포함할 것
<pre><code>
def rec_func(i):
    if i == 100:
        return
    print(f'{i} 번째 함수에서 {i + 1}재귀 함수를 호출합니다')
    rec_func(i+1)
    print(f'{i} 번째 함수가 종료되었습니다.')

rec_func(1)
</code></pre>

### 유클리드 호제법
* **두 자연수에 대한 최대공약수를 구하는 알고리즘**
* 자연수 A,B (A > B)에 대하여 A를 B로 나눈 나머지를 R이라고 하면,<br /> A와 B의 최대공약수는 B와 R의 최대공약수와 같음
![](uclid_gcd.png){: width="50%"}

### DFS
* 깊이 우선 탐색
* 깊은 부분을 우선적으로 탐색하는 알고리즘
* **스택** 이나 **재귀함수**를 이용하여 구현
  * 탐색 시작 노드를 스택에 삽입하고 방문 처리
  * 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문 처리, 방문하지 않은 노드가 없으면 스택에서 최상단 노드 꺼내
  * 2번의 과정을 수행할 수 없을 때까지 반복
![](DFS.png){: width="50%"}


### BFS 
* **너비 우선 탐색**이라고 부르며, 그래프에서 가까운 노드부터 우선적으로 탐색하는 알고리즘.
* BFS는 **큐** 를 사용
  * 탐색 시작 노드를 큐에 삽입하고 방문 처리를 함
  * 큐에서 노드를 꺼낸 뒤에 해단 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리
  * 2번 과정 수행X 때 까지 반복
  

<pre><code>
</code></pre>
